<!DOCTYPE html>
<html lang="nl">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Natuurkunde Krachtenspel</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- React and ReactDOM -->
    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    <!-- Babel for in-browser JSX/TS transpilation -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
      @keyframes particle-fade-out {
        from {
          transform: translate(0, 0) scale(1);
          opacity: 1;
        }
        to {
          transform: var(--transform-end);
          opacity: 0;
          scale: 0;
        }
      }
      .particle-animation {
        animation: particle-fade-out 0.6s ease-out forwards;
      }
    </style>
  </head>
  <body class="bg-slate-900 text-white">
    <div id="root"></div>
    
    <script type="text/babel" data-type="module">
      const { StrictMode, useState, useCallback, useEffect, useRef, useMemo } = React;
      const { createRoot } = ReactDOM;

      // --- From types.ts ---
      const ForceType = {
        Zwaartekracht: 'Zwaartekracht',
        Normaalkracht: 'Normaalkracht',
        Wrijvingskracht: 'Wrijvingskracht',
      };

      // --- From constants.ts ---
      const GAME_WIDTH = 800;
      const GAME_HEIGHT = 600;
      const PLAYER_WIDTH = 60;
      const PLAYER_HEIGHT = 20;
      const PLAYER_SPEED = 10;
      const PLAYER_Y_OFFSET = 30;
      const ARROW_WIDTH = 50;
      const ARROW_HEIGHT = 50;
      const BASE_ARROW_SPEED = 1.5;
      const ARROW_SPAWN_INTERVAL = 2000; // ms
      const PROJECTILE_WIDTH = 8;
      const PROJECTILE_HEIGHT = 40;
      const PROJECTILE_SPEED = 7;
      const INITIAL_LIVES = 3;
      const MAX_LIVES = 5;
      const FORCES_CONFIG = {
        [ForceType.Zwaartekracht]: {
          name: 'Zwaartekracht',
          color: 'stroke-red-400',
          bgColor: 'bg-red-500/80',
          borderColor: 'border-red-400',
          rotation: 0,
        },
        [ForceType.Normaalkracht]: {
          name: 'Normaalkracht',
          color: 'stroke-blue-400',
          bgColor: 'bg-blue-500/80',
          borderColor: 'border-blue-400',
          rotation: 180,
        },
        [ForceType.Wrijvingskracht]: {
          name: 'Wrijvingskracht',
          color: 'stroke-yellow-400',
          bgColor: 'bg-yellow-500/80',
          borderColor: 'border-yellow-400',
        },
      };

      // --- From utils/SoundManager.ts ---
      let audioContext = null;
      const initAudio = async () => {
        if (!audioContext) {
          try {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
          } catch (e) {
            console.error("Web Audio API is not supported in this browser");
          }
        }
        // Resume the audio context if it's in a suspended state (required by modern browsers)
        if (audioContext && audioContext.state === 'suspended') {
          await audioContext.resume();
        }
      };
      const playSound = (type, frequency, duration, volume = 0.5) => {
        if (!audioContext || audioContext.state !== 'running') return;
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);
        oscillator.type = type;
        oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
        gainNode.gain.setValueAtTime(volume, audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.0001, audioContext.currentTime + duration);
        oscillator.start(audioContext.currentTime);
        oscillator.stop(audioContext.currentTime + duration);
      };
      const playShoot = () => {
        playSound('sine', 880, 0.05, 0.2);
        playSound('square', 440, 0.05, 0.1);
      };
      const playHitCorrect = () => {
        if (!audioContext) return;
        playSound('sine', 523.25, 0.1, 0.4);
        setTimeout(() => playSound('sine', 783.99, 0.15, 0.4), 60);
      };
      const playHitIncorrect = () => playSound('sawtooth', 164.81, 0.15, 0.3);
      const playLoseLife = () => {
        if (!audioContext) return;
        playSound('square', 130.81, 0.1, 0.4);
        setTimeout(() => playSound('square', 123.47, 0.2, 0.4), 50);
      };
      const playLevelUp = () => {
        if (!audioContext) return;
        const baseVol = 0.3;
        const playNote = (freq, delay) => setTimeout(() => playSound('triangle', freq, 0.1, baseVol), delay);
        playNote(523.25, 0);
        playNote(659.25, 80);
        playNote(783.99, 160);
        playNote(1046.50, 240);
      };
      const playGameOver = () => {
        if (!audioContext) return;
        playSound('sawtooth', 200, 0.4, 0.4);
        setTimeout(() => playSound('sawtooth', 100, 0.5, 0.4), 100);
      };
      const playButtonClick = () => playSound('sine', 1200, 0.08, 0.2);
      
      // --- From components/ArrowIcon.tsx ---
      const ArrowIcon = ({ type, rotation }) => {
        const config = FORCES_CONFIG[type];
        return (
          <svg
            xmlns="http://www.w3.org/2000/svg"
            viewBox="0 0 24 24"
            fill="none"
            className={`w-full h-full ${config.color}`}
            style={{ transform: `rotate(${rotation}deg)` }}
            strokeWidth={1.5}
          >
              <filter id={`glow-${type}`} x="-50%" y="-50%" width="200%" height="200%">
                  <feGaussianBlur stdDeviation="1.5" result="coloredBlur"/>
                  <feMerge>
                      <feMergeNode in="coloredBlur"/>
                      <feMergeNode in="SourceGraphic"/>
                  </feMerge>
              </filter>
              <g style={{ filter: `url(#glow-${type})` }}>
                  <path strokeLinecap="round" strokeLinejoin="round" d="M15.75 17.25 12 21m0 0-3.75-3.75M12 21V3" />
              </g>
          </svg>
        );
      };

      // --- From components/Player.tsx ---
      const Player = ({ x }) => {
        const points = `${PLAYER_WIDTH / 2},0 ${PLAYER_WIDTH},${PLAYER_HEIGHT} 0,${PLAYER_HEIGHT}`;
        return (
          <svg
            className="absolute"
            style={{
              transform: `translateX(${x}px)`,
              willChange: 'transform',
              bottom: PLAYER_Y_OFFSET - PLAYER_HEIGHT,
              width: PLAYER_WIDTH,
              height: PLAYER_HEIGHT,
              filter: 'drop-shadow(0 0 10px rgba(0, 255, 255, 0.7)) drop-shadow(0 0 4px rgba(150, 255, 255, 0.8))',
            }}
            viewBox={`0 0 ${PLAYER_WIDTH} ${PLAYER_HEIGHT}`}
          >
            <polygon
                points={points}
                className="fill-cyan-500 stroke-cyan-300"
                strokeWidth="2"
                strokeLinejoin="round"
            />
          </svg>
        );
      };

      // --- From components/FallingArrow.tsx ---
      const FallingArrow = ({ arrow }) => {
        return (
          <div
            className="absolute"
            style={{
              left: arrow.x,
              top: arrow.y,
              width: arrow.width,
              height: arrow.height,
            }}
          >
            <ArrowIcon type={arrow.type} rotation={arrow.rotation} />
          </div>
        );
      };

      // --- From components/Projectile.tsx ---
      const ProjectileComponent = ({ projectile }) => {
        const config = FORCES_CONFIG[projectile.type];
        return (
          <div
            className={`absolute rounded-full ${config.bgColor}`}
            style={{
              left: projectile.x - projectile.width / 2,
              top: projectile.y - projectile.height / 2,
              width: projectile.width,
              height: projectile.height,
              boxShadow: `0 0 20px 4px var(--tw-shadow-color)`,
              '--tw-shadow-color': `var(--fallback-color, ${config.borderColor.replace('border-','').replace('-400','')})`
            }}
          >
          </div>
        );
      };
      
      // --- From components/Explosion.tsx ---
      const ExplosionComponent = ({ explosion, onComplete }) => {
        const { x, y, type, id } = explosion;
        const config = FORCES_CONFIG[type];
        const PARTICLE_COUNT = 12;
        const SPREAD = 60;
        const DURATION = 600;

        useEffect(() => {
          const timer = setTimeout(() => {
            onComplete(id);
          }, DURATION);
          return () => clearTimeout(timer);
        }, [id, onComplete]);

        const particles = useMemo(() => {
          return Array.from({ length: PARTICLE_COUNT }).map((_, index) => {
            const angle = (index / PARTICLE_COUNT) * 2 * Math.PI;
            const randomSpread = SPREAD * (0.5 + Math.random() * 0.5);
            const endX = Math.cos(angle) * randomSpread;
            const endY = Math.sin(angle) * randomSpread;
            const size = 4 + Math.random() * 4;
            return {
              id: index,
              style: {
                '--transform-end': `translate(${endX}px, ${endY}px)`,
                width: `${size}px`,
                height: `${size}px`,
              },
            };
          });
        }, [type]);

        return (
          <div className="absolute" style={{ left: x, top: y, pointerEvents: 'none' }}>
            {particles.map(p => (
              <div
                key={p.id}
                className={`absolute rounded-full particle-animation ${config.bgColor}`}
                style={p.style}
              />
            ))}
          </div>
        );
      };

      // --- From components/HUD.tsx ---
      const HeartIcon = ({className}) => (
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" className={className}>
              <path d="m11.645 20.91-.007-.003-.022-.012a15.247 15.247 0 0 1-1.344-.682 15.64 15.64 0 0 1-1.292-1.043A3.856 3.856 0 0 1 6.5 12.645V12.5A2.5 2.5 0 0 1 9 10h6a2.5 2.5 0 0 1 2.5 2.5v.145c0 .252.039.5.118.742l.022.068a15.64 15.64 0 0 1-1.292 1.043 15.247 15.247 0 0 1-1.344.682l-.022.012-.007.003-.001.001a.752.752 0 0 1-.704 0l-.001-.001Z" />
          </svg>
      );
      const HUD = ({ score, lives, level }) => {
        return (
          <div className="absolute top-0 left-0 right-0 p-4 flex justify-between items-center text-lg z-10 bg-black/20">
            <div className="font-bold">
              SCORE: <span className="text-yellow-300 tabular-nums">{score}</span>
            </div>
            <div className="font-bold">
              LEVEL: <span className="text-cyan-300 tabular-nums">{level}</span>
            </div>
            <div className="flex items-center gap-2">
              <span className="font-bold">LEVEN:</span>
              <div className="flex">
                  {Array.from({ length: MAX_LIVES }).map((_, i) => (
                      <HeartIcon key={i} className={`w-6 h-6 transition-colors ${i < lives ? 'text-red-500' : 'text-slate-600'}`} />
                  ))}
              </div>
            </div>
          </div>
        );
      };

      // --- From components/Controls.tsx ---
      const Controls = ({ selectedAmmo, onSelectAmmo }) => {
        const forceTypes = Object.values(ForceType);
        return (
          <div className="mt-4 p-2 bg-slate-800/80 rounded-lg w-full max-w-[800px] border-2 border-slate-700">
              <p className="text-center text-sm text-slate-400 mb-2">Selecteer een kracht om te schieten</p>
              <div className="grid grid-cols-3 gap-2">
                  {forceTypes.map(type => {
                      const config = FORCES_CONFIG[type];
                      const isSelected = selectedAmmo === type;
                      return (
                      <button
                          key={type}
                          onClick={() => onSelectAmmo(type)}
                          className={`p-3 rounded-md text-center font-bold text-sm md:text-base transition-all duration-200 border-2 ${
                          isSelected
                              ? `${config.borderColor} ${config.bgColor} scale-105 shadow-lg`
                              : 'bg-slate-700 border-transparent hover:bg-slate-600'
                          }`}
                      >
                          {config.name}
                      </button>
                      );
                  })}
              </div>
          </div>
        );
      };

      // --- From components/GameOver.tsx ---
      const GameOver = ({ score, onRestart, onMenu }) => {
        const handleRestart = () => { playButtonClick(); onRestart(); };
        const handleMenu = () => { playButtonClick(); onMenu(); };
        return (
          <div className="bg-slate-800/50 p-8 rounded-lg text-center flex flex-col items-center gap-4 border-2 border-slate-700">
            <h2 className="text-3xl font-bold text-red-500">Game Over</h2>
            <p className="text-xl text-slate-300">Je eindscore is:</p>
            <p className="text-5xl font-bold text-yellow-300 mb-4">{score}</p>
            <div className="flex gap-4">
              <button
                onClick={handleRestart}
                className="bg-cyan-500 hover:bg-cyan-400 text-slate-900 font-bold py-2 px-6 rounded-lg text-lg transition-transform transform hover:scale-105"
              >
                Opnieuw Spelen
              </button>
              <button
                onClick={handleMenu}
                className="bg-slate-600 hover:bg-slate-500 text-white font-bold py-2 px-6 rounded-lg text-lg transition-transform transform hover:scale-105"
              >
                Hoofdmenu
              </button>
            </div>
          </div>
        );
      };
      
      // --- From components/MainMenu.tsx ---
      const MainMenu = ({ onStartGame }) => {
        return (
          <div className="bg-slate-800/50 p-8 rounded-lg text-center flex flex-col items-center gap-6 border-2 border-slate-700">
            <h2 className="text-3xl font-bold text-yellow-300">Welkom!</h2>
            <div className="max-w-md text-slate-300 space-y-4">
              <p>In dit spel vallen krachten (als pijlen) naar beneden. Jouw taak is om de juiste kracht te selecteren en op de corresponderende pijl te schieten.</p>
              <p className="font-semibold">Besturing:</p>
              <ul className="list-disc list-inside text-left mx-auto max-w-xs">
                <li><span className="font-bold text-cyan-400">Pijltjes</span>: Beweeg je schieter</li>
                <li><span className="font-bold text-cyan-400">1, 2, 3 / Klikken</span>: Selecteer een kracht</li>
                <li><span className="font-bold text-cyan-400">Spatiebalk</span>: Schiet de geselecteerde kracht</li>
              </ul>
            </div>
            <button
              onClick={onStartGame}
              className="bg-green-500 hover:bg-green-400 text-slate-900 font-bold py-3 px-8 rounded-lg text-xl transition-transform transform hover:scale-105 shadow-lg shadow-green-500/30"
            >
              Start Spel
            </button>
          </div>
        );
      };

      // --- From components/Game.tsx ---
      const checkCollision = (obj1, obj2) => {
        return obj1.x < obj2.x + obj2.width &&
              obj1.x + obj1.width > obj2.x &&
              obj1.y < obj2.y + obj2.height &&
              obj1.y + obj1.height > obj2.y;
      };
      const Game = ({ onGameOver }) => {
        const [playerX, setPlayerX] = useState(GAME_WIDTH / 2 - PLAYER_WIDTH / 2);
        const [arrows, setArrows] = useState([]);
        const [projectiles, setProjectiles] = useState([]);
        const [explosions, setExplosions] = useState([]);
        const [selectedAmmo, setSelectedAmmo] = useState(ForceType.Zwaartekracht);
        const [score, setScore] = useState(0);
        const [lives, setLives] = useState(INITIAL_LIVES);
        const [level, setLevel] = useState(1);
        const keysPressed = useRef({});
        const gameLoopRef = useRef(null);
        const lastArrowSpawnTime = useRef(Date.now());
        const gameStateRef = useRef({ score, lives, level, arrows, projectiles, playerX, selectedAmmo });

        useEffect(() => {
          gameStateRef.current = { score, lives, level, arrows, projectiles, playerX, selectedAmmo };
        }, [score, lives, level, arrows, projectiles, playerX, selectedAmmo]);

        const removeExplosion = useCallback((id) => {
          setExplosions(prev => prev.filter(exp => exp.id !== id));
        }, []);

        const spawnArrow = useCallback(() => {
          const forceTypes = Object.values(ForceType);
          const type = forceTypes[Math.floor(Math.random() * forceTypes.length)];
          const x = Math.random() * (GAME_WIDTH - ARROW_WIDTH);
          let rotation;
          if (type === ForceType.Wrijvingskracht) {
            rotation = Math.random() < 0.5 ? 90 : 270;
          } else {
            rotation = FORCES_CONFIG[type].rotation;
          }
          const newArrow = { id: Date.now(), x, y: -ARROW_HEIGHT, type, width: ARROW_WIDTH, height: ARROW_HEIGHT, rotation };
          setArrows(prev => [...prev, newArrow]);
        }, [setArrows]);

        const fireProjectile = useCallback(() => {
          playShoot();
          setProjectiles(prev => [
            ...prev,
            {
              id: Date.now(),
              x: gameStateRef.current.playerX + PLAYER_WIDTH / 2,
              y: GAME_HEIGHT - PLAYER_Y_OFFSET,
              type: gameStateRef.current.selectedAmmo,
              width: PROJECTILE_WIDTH,
              height: PROJECTILE_HEIGHT,
            },
          ]);
        }, []);

        const handleKeyDown = useCallback((e) => {
          keysPressed.current[e.key] = true;
          if (e.code === 'Space') {
            e.preventDefault();
            fireProjectile();
          }
          switch (e.key) {
            case '1': setSelectedAmmo(ForceType.Zwaartekracht); break;
            case '2': setSelectedAmmo(ForceType.Normaalkracht); break;
            case '3': setSelectedAmmo(ForceType.Wrijvingskracht); break;
          }
        }, [fireProjectile, setSelectedAmmo]);

        const handleKeyUp = useCallback((e) => {
          keysPressed.current[e.key] = false;
        }, []);

        useEffect(() => {
          window.addEventListener('keydown', handleKeyDown);
          window.addEventListener('keyup', handleKeyUp);
          return () => {
            window.removeEventListener('keydown', handleKeyDown);
            window.removeEventListener('keyup', handleKeyUp);
          };
        }, [handleKeyDown, handleKeyUp]);

        useEffect(() => {
          const gameLoop = () => {
            if (keysPressed.current['ArrowLeft'] || keysPressed.current['ArrowRight']) {
              setPlayerX(prevX => {
                let newX = prevX;
                if (keysPressed.current['ArrowLeft']) newX -= PLAYER_SPEED;
                if (keysPressed.current['ArrowRight']) newX += PLAYER_SPEED;
                return Math.max(0, Math.min(GAME_WIDTH - PLAYER_WIDTH, newX));
              });
            }

            const { level: currentLevel, arrows: currentArrows, projectiles: currentProjectiles, lives: previousLives, score: previousScore } = gameStateRef.current;
            const arrowSpeed = BASE_ARROW_SPEED + (currentLevel - 1) * 0.3;

            let livesToLose = 0;
            let scoreToAdd = 0;
            const explosionsToAdd = [];
            const hitArrowIds = new Set();
            
            // 1. Calculate projectile and collision outcomes
            const nextProjectiles = currentProjectiles
                .map(p => ({ ...p, y: p.y - PROJECTILE_SPEED }))
                .filter(p => {
                    if (p.y <= -PROJECTILE_HEIGHT) return false;

                    const hitArrow = currentArrows.find(arrow => !hitArrowIds.has(arrow.id) && checkCollision(p, arrow));
                    if (hitArrow) {
                        hitArrowIds.add(hitArrow.id);
                        explosionsToAdd.push({ id: Date.now() + Math.random(), x: p.x, y: p.y, type: p.type });
                        if (p.type === hitArrow.type) {
                            playHitCorrect();
                            scoreToAdd += 10;
                        } else {
                            playHitIncorrect();
                            livesToLose += 1;
                        }
                        return false; // Projectile is consumed
                    }
                    return true; // Projectile continues
                });

            // 2. Calculate arrow outcomes
            const nextArrows = currentArrows
                .filter(a => !hitArrowIds.has(a.id))
                .map(arrow => ({ ...arrow, y: arrow.y + arrowSpeed }))
                .filter(arrow => {
                    if (arrow.y > GAME_HEIGHT) {
                        playLoseLife();
                        livesToLose += 1;
                        return false;
                    }
                    return true;
                });
            
            // 3. Apply all state changes at once
            setProjectiles(nextProjectiles);
            setArrows(nextArrows);
            if (explosionsToAdd.length > 0) setExplosions(prev => [...prev, ...explosionsToAdd]);
            if (livesToLose > 0) setLives(l => Math.max(0, l - livesToLose));
            if (scoreToAdd > 0) setScore(s => s + scoreToAdd);

            // 4. Check for game over
            if (previousLives > 0 && (previousLives - livesToLose) <= 0) {
              onGameOver(previousScore + scoreToAdd);
              return;
            }

            // 5. Spawn new arrows
            if (Date.now() - lastArrowSpawnTime.current > ARROW_SPAWN_INTERVAL / (1 + (currentLevel - 1) * 0.15)) {
              spawnArrow();
              lastArrowSpawnTime.current = Date.now();
            }

            // 6. Update Level
            if (previousScore + scoreToAdd > currentLevel * 100) {
              playLevelUp();
              setLevel(l => l + 1);
              setLives(l => Math.min(MAX_LIVES, l + 1));
            }
            
            gameLoopRef.current = requestAnimationFrame(gameLoop);
          };
          gameLoopRef.current = requestAnimationFrame(gameLoop);
          return () => {
            if (gameLoopRef.current) cancelAnimationFrame(gameLoopRef.current);
          };
        }, [onGameOver, spawnArrow]);

        return (
          <div className="flex flex-col items-center">
            <div
              className="relative bg-slate-800 border-2 border-cyan-400/50 shadow-lg shadow-cyan-500/20 overflow-hidden"
              style={{ width: GAME_WIDTH, height: GAME_HEIGHT }}
            >
              <HUD score={score} lives={lives} level={level} />
              <Player x={playerX} />
              {arrows.map(arrow => <FallingArrow key={arrow.id} arrow={arrow} />)}
              {projectiles.map(p => <ProjectileComponent key={p.id} projectile={p} />)}
              {explosions.map(exp => <ExplosionComponent key={exp.id} explosion={exp} onComplete={removeExplosion} />)}
            </div>
            <Controls selectedAmmo={selectedAmmo} onSelectAmmo={setSelectedAmmo} />
          </div>
        );
      };

      // --- From App.tsx ---
      const App = () => {
        const [gameState, setGameState] = useState('MainMenu');
        const [score, setScore] = useState(0);

        const startGame = useCallback(async () => {
          await initAudio();
          playButtonClick();
          setScore(0);
          setGameState('Playing');
        }, []);

        const endGame = useCallback((finalScore) => {
          playGameOver();
          setScore(finalScore);
          setGameState('GameOver');
        }, []);

        const returnToMenu = useCallback(() => {
          setGameState('MainMenu');
        }, []);

        const renderGameState = () => {
          switch (gameState) {
            case 'Playing':
              return <Game onGameOver={endGame} />;
            case 'GameOver':
              return <GameOver score={score} onRestart={startGame} onMenu={returnToMenu} />;
            case 'MainMenu':
            default:
              return <MainMenu onStartGame={startGame} />;
          }
        };

        return (
          <div className="min-h-screen bg-slate-900 text-white flex flex-col items-center justify-center p-4 font-sans">
            <div className="w-full max-w-4xl mx-auto">
              <header className="text-center mb-4">
                <h1 className="text-4xl md:text-5xl font-bold text-cyan-400 tracking-wider">
                  Natuurkunde Krachtenspel
                </h1>
                <p className="text-slate-400 mt-2">Leer krachten herkennen op een hellend vlak!</p>
              </header>
              <main>
                {renderGameState()}
              </main>
              <footer className="text-center mt-6 text-sm text-slate-500">
                <p>Gemaakt voor MBO-studenten. Gebruik de pijltjestoetsen om te bewegen, selecteer een kracht en druk op de spatiebalk om te schieten.</p>
              </footer>
            </div>
          </div>
        );
      };

      // --- From index.tsx ---
      const rootElement = document.getElementById('root');
      if (!rootElement) {
        throw new Error("Could not find root element to mount to");
      }
      const root = createRoot(rootElement);
      root.render(
        <StrictMode>
          <App />
        </StrictMode>
      );
    </script>
  </body>
</html>
