<!DOCTYPE html>
<html lang="nl">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Memory: Match de termen!</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script type="importmap">
      {
        "imports": {
          "react": "https://esm.sh/react@19.2.3",
          "react-dom/client": "https://esm.sh/react-dom@19.2.3/client"
        }
      }
    </script>
    <style>
      @keyframes fade-in {
        from { opacity: 0; transform: translateY(10px); }
        to { opacity: 1; transform: translateY(0); }
      }
      .animate-fade-in { animation: fade-in 0.5s ease-out forwards; }
    </style>
  </head>
  <body class="bg-gray-100">
    <div id="root"></div>

    <script type="module">
      import React, { useState, useEffect, useCallback, useRef } from 'react';
      import ReactDOM from 'react-dom/client';

      function sendScoreToPlatform(score100) {
        const params = new URLSearchParams(window.location.search);
        const raw = params.get('game');
        const gameNum = raw !== null && raw !== '' ? Number(raw) : 1;

        const safeScore = Math.max(0, Math.min(100, Math.round(Number(score100) || 0)));

        window.parent.postMessage(
          { type: 'GAME_SCORE', gameNum: Number.isFinite(gameNum) ? gameNum : 1, score: safeScore },
          window.location.origin
        );
      }

      const TERM_PAIRS = [
        { en: "inclined plane",       nl: "hellend vlak" },
        { en: "angle",                nl: "hoek" },
        { en: "distance",             nl: "afstand" },
        { en: "speed",                nl: "snelheid" },
        { en: "acceleration",         nl: "versnelling" },
        { en: "constant speed",       nl: "constante snelheid" },
        { en: "deceleration",         nl: "vertraging" },
        { en: "friction coefficient", nl: "wrijvingscoëfficiënt" }
      ];

      let audioContext = null;

      const getAudioContext = () => {
        if (typeof window !== 'undefined' && (window.AudioContext || window.webkitAudioContext)) {
          if (!audioContext) {
            try {
              audioContext = new (window.AudioContext || window.webkitAudioContext)();
            } catch (e) {
              return null;
            }
          }
        }
        return audioContext;
      };

      const playSound = (type, frequency, duration, volume = 0.1) => {
        const context = getAudioContext();
        if (!context) return;

        if (context.state === 'suspended') context.resume();

        const oscillator = context.createOscillator();
        const gainNode = context.createGain();

        oscillator.type = type;
        oscillator.frequency.setValueAtTime(frequency, context.currentTime);

        gainNode.gain.setValueAtTime(volume, context.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.0001, context.currentTime + duration);

        oscillator.connect(gainNode);
        gainNode.connect(context.destination);

        oscillator.start(context.currentTime);
        oscillator.stop(context.currentTime + duration);
      };

      const playFlipSound = () => playSound('triangle', 440, 0.1, 0.05);
      const playMatchSound = () => {
        playSound('sine', 660, 0.1);
        setTimeout(() => playSound('sine', 880, 0.15), 100);
      };
      const playNoMatchSound = () => playSound('square', 220, 0.2);
      const playWinSound = () => {
        const notes = [523.25, 659.25, 783.99, 1046.50];
        notes.forEach((note, index) => {
          setTimeout(() => playSound('sine', note, 0.15), index * 120);
        });
      };

      const Card = ({ card, isFlipped, isMatched, onClick }) => {
        const isVisible = isFlipped || isMatched;

        return (
          React.createElement("button",
            {
              type: "button",
              className: "group relative h-24 sm:h-28 rounded-xl cursor-pointer [perspective:1000px] transition-transform duration-150 hover:-translate-y-1",
              onClick,
              "aria-pressed": isVisible
            },
            React.createElement("div", { className: `relative w-full h-full transition-transform duration-500 [transform-style:preserve-3d] ${isVisible ? "[transform:rotateY(180deg)]" : ""}` },
              React.createElement("div", { className: "absolute w-full h-full flex items-center justify-center p-2 text-center rounded-xl border font-semibold select-none [backface-visibility:hidden] bg-white border-gray-200 shadow-md" },
                React.createElement("span", { className: "text-3xl font-bold text-gray-500" }, "?")
              ),
              React.createElement("div", { className: `absolute w-full h-full flex items-center justify-center p-2 text-center rounded-xl border font-semibold select-none [backface-visibility:hidden] [transform:rotateY(180deg)] text-sm sm:text-base ${isMatched ? "bg-green-100 border-green-500" : "bg-indigo-50 border-indigo-400"}` },
                React.createElement("span", null, card.text)
              )
            )
          )
        );
      };

      const App = () => {
        const [deck, setDeck] = useState([]);
        const [flippedIndices, setFlippedIndices] = useState([]);
        const [matchedPairIds, setMatchedPairIds] = useState([]);
        const [moves, setMoves] = useState(0);
        const [lockBoard, setLockBoard] = useState(false);
        const [message, setMessage] = useState({ text: '', type: 'info' });
        const [score, setScore] = useState(0);

        const sentScoreRef = useRef(false);

        const shuffleArray = (array) => {
          const newArray = [...array];
          for (let i = newArray.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
          }
          return newArray;
        };

        const startNewGame = useCallback(() => {
          let uniqueId = 0;
          const newDeck = TERM_PAIRS.flatMap((pair, index) => {
            const pairId = index + 1;
            return [
              { id: ++uniqueId, pairId, text: pair.en, lang: 'en' },
              { id: ++uniqueId, pairId, text: pair.nl, lang: 'nl' },
            ];
          });

          sentScoreRef.current = false;
          setDeck(shuffleArray(newDeck));
          setFlippedIndices([]);
          setMatchedPairIds([]);
          setMoves(0);
          setScore(0);
          setLockBoard(false);
          setMessage({ text: 'Zoek steeds één Engelse en één Nederlandse term die bij elkaar horen.', type: 'info' });
        }, []);

        useEffect(() => {
          startNewGame();
        }, [startNewGame]);

        useEffect(() => {
          if (flippedIndices.length < 2) return;

          setLockBoard(true);
          setMoves((prev) => prev + 1);

          const [a, b] = flippedIndices;
          const first = deck[a];
          const second = deck[b];

          if (first.pairId === second.pairId && first.lang !== second.lang) {
            playMatchSound();
            setTimeout(() => {
              setMatchedPairIds(prev => [...prev, first.pairId]);
              setFlippedIndices([]);
              setLockBoard(false);
            }, 600);
          } else {
            playNoMatchSound();
            setTimeout(() => {
              setFlippedIndices([]);
              setLockBoard(false);
            }, 1000);
          }
        }, [flippedIndices, deck]);

        /* AUTOMATISCHE SCORE 100 BIJ ALLES GOED */
        useEffect(() => {
          const allCorrect = matchedPairIds.length === TERM_PAIRS.length;
          if (!allCorrect) return;

          const finalScore = 100;

          if (score !== finalScore) setScore(finalScore);

          playWinSound();
          setMessage({
            text: `Top! Je hebt alle paren gevonden in ${moves} beurten. Score: ${finalScore}/100.`,
            type: 'success',
          });
          setLockBoard(true);

          if (!sentScoreRef.current) {
            sentScoreRef.current = true;
            sendScoreToPlatform(finalScore);
          }
        }, [matchedPairIds, moves, score]);
        /* EINDE LOGICA */

        const handleCardClick = (index) => {
          if (lockBoard || flippedIndices.includes(index) || matchedPairIds.includes(deck[index].pairId)) return;
          playFlipSound();
          setFlippedIndices(prev => [...prev, index]);
        };

        return React.createElement("main", { className: "max-w-4xl w-full mx-auto p-4" },
          React.createElement("div", { className: "grid grid-cols-2 sm:grid-cols-4 gap-3" },
            deck.map((card, index) =>
              React.createElement(Card, {
                key: card.id,
                card,
                isFlipped: flippedIndices.includes(index),
                isMatched: matchedPairIds.includes(card.pairId),
                onClick: () => handleCardClick(index)
              })
            )
          ),
          React.createElement("div", { className: "mt-4 text-center font-semibold" }, message.text),
          React.createElement("div", { className: "mt-2 text-center" }, `Score: ${score}/100`)
        );
      };

      const root = ReactDOM.createRoot(document.getElementById('root'));
      root.render(React.createElement(App));
    </script>
  </body>
</html>
